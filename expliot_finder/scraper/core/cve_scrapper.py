"""CVE(Common Vulnerabilities and Exposures) scrapper.

Leaning on version of the service that was captured after the target
scanned by 'vulnerability_scanner' module, this module will try to find most
relevant CVE's in web by using scraping technique. If this module find CVE's
the chance to finding a matching exploit increases. Information detected by
this module will be saved and returned in the following form:

    .. code-block:: python

        # Returns URL the most suitable CVE to the captured version of the
        # service
        'https://www.cvedetails.com/cve/CVE-2002-1646/'
"""

__all__ = ("SuitableCVEFinder",)

import re
from typing import List

import aiohttp
from bs4 import BeautifulSoup


class SuitableCVEFinder:
    """Scraper of page 'https://www.cvedetails.com' in order to find most
    relevant CVE for the captured 'service.

    If the script executes methods in this class, it means that 'sites_finder'
    module found page with few CVE's that's are stored in HTML table. The
    purpose of the methods in this class is to extract the best suitable CVE
    for service that was captured after the target was scanned by module named:
    'vulnerability_scanner'.

    Attributes:
        cve_table_url:
            URL to page with table containing a few CVE's. Those CVE's are for
            captured service but this table contains a few of them for
            different versions. This scraper will extract one best matching
            CVE which will be returned to final output table.
        service_version:
            Version of the service that was captured after the target was
            scanned by 'vulnerability_scanner' module.

    .. automethod:: __extracted_service_ver_in_nums
    .. automethod:: __get_page_content
    .. automethod:: __scrap_cve_table_page
    """

    __slots__ = "cve_table_url", "service_version",

    def __init__(self, cve_table_url: str, service_version: str) -> None:
        self.cve_table_url: str = cve_table_url
        self.service_version: str = service_version

    def __extracted_service_ver_in_nums(self) -> List[str]:
        """Extract service version in numbers.

        Parse captured 'service version' to extract only numbers without any
        letters. The page that was provided in 'cve_table_url' class attribute
        stores URL to HTML table with CVE's for captured 'service version'.
        After extracting version of the service only in nums, scraper will be
        able to find the most suitable CVE for captured 'service'.

        Returns:
            List with a string of numbers from 'service version', without any
            letters or words.
        """
        parsed_service_ver: List[str] = re.split("-|_", self.service_version)
        for element in parsed_service_ver:
            if not any(char.isdigit() for char in element):
                parsed_service_ver.remove(element)
        return parsed_service_ver

    async def __get_page_content(self) -> bytes:
        """Create async client session and perform a GET request.

        Perform a GET request to page ('self.cve_table_url') with CVE's stored
        in HTML table.

        Returns: Content of page with few CVE's stored in HTML table.
        """
        async with aiohttp.ClientSession() as session:
            async with session.get(self.cve_table_url) as response:
                return await response.read()

    @staticmethod
    async def __scrap_cve_table_page(
            page_content: bytes, parsed_service_ver: List[str]) -> str | None:
        """Scrape provided site with HTML table stored few CVE's to find
        best matching CVE for captured service.

        The 'page_content' will hold a page with an HTML table filled with all
        CVE's which partially match service. 'Partially' means that this HTML
        table was found by 'sites_finder' module and this module was looking
        for CVE by 'service name' not exactly by 'service version'. So this
        HTML table will store few CVE's for different versions of captured
        service and this scrapper will extract best matching CVE by searching
        for the exact version of the captured service. Provide page in pram:
        'page_content' must be from domain: (https://www.cvedetails.com).

        Args:
            parsed_service_ver:
                List with a string of numbers from 'service version',
                without any letters or words. Using the version of the service
                prepared in this way, the scraper will find the most suitable
                CVE for this captured service.
            page_content:
                Content of page from domain: 'https://www.cvedetails.com'
                with few CVE's stored in HTML table that partially match
                service.

        Returns:
            URL the most suitable CVE to the captured version of the service.
        """
        soup = BeautifulSoup(page_content.decode("UTF-8"), "html.parser")

        for element in soup.find_all("td", class_="cvesummarylong"):
            if any(word in element.text for word in parsed_service_ver):
                cve_a_tag = (element.find_previous().find_previous(
                ).find_parent().find("td").find_next("td").find("a"))
                return f"https://www.cvedetails.com{cve_a_tag['href']}"

    async def find_suitable_cve(self) -> str | None:
        """A handle to start scraping a provided HTML page with CVE's in order
        to find most suitable CVE for captured 'services' by
        'vulnerability_scanner' module.

        Returns:
            One single URL to most suitable CVE for captured 'service'.
        """
        parsed_service_ver: List[str] = self.__extracted_service_ver_in_nums()
        page_content = await self.__get_page_content()

        return await self.__scrap_cve_table_page(page_content,
                                                 parsed_service_ver)
