"""Logic of 'tcp_port_scanner' module.

This module will try to detect:
    - open ports (what open ports selected target has)
    - services names (what services running on these open ports)
    - versions of these running services
Information detected by this module will be saved and returned in the following
form:

.. code-block:: python

        # Returns open ports, services names running on those open ports and
        # versions of those services of the chosen target
         ports_services: [
                        PortService(
                            # Detected open port in target
                            port_number=22,
                            # Detected running service on this opened port
                            service_name='ssh',
                            # Detected versions of this running service
                            service_version='SSH-2.0-dropbear_2011.54'
                        ),
                        PortService(
                            port_number=80,
                            service_name='http',
                            service_version='Unknown'
                        )
                        ...
                    ]
"""
from __future__ import annotations

__all__ = ("PortServiceScannerTCP",)

import asyncio
import socket
from asyncio.exceptions import TimeoutError
from collections import namedtuple
from functools import partial
from typing import AsyncIterable, Awaitable, Callable, List

from expliot_finder.vulnerability_scanner.core.utils import run_concurrently
from .const import PORTS_AND_SERVICES
from .state import OpenPort, Service
from .exceptions import PortRangeError


class PortServiceScannerTCP:
    """Asynchronous TCP port/services scanner.

    The methods stored in this class will perform port scan asynchronously
    thus, other modules will not be blocked be scanning. While scanning the
    methods in this class will try to get the following information about
    the target:
        - open ports (numbers)
        - names of services listening on these ports
        - versions of these listening services
    To obtain this about information, 30 coroutines will be created per each
    iteration over 'port_range'. Those 30 coroutines will use TCP socket in
    IPv4 addresses family.

    Attributes:
        async_loop:
            Running event loop in the current OS thread.
        captured_sensitive_info:
            Global dataclass that stores detected sensitive information about
            the selected target to scan. This dataclass can be easily
            transformed to the dictionary.
        coroutines_number:
            A number of coroutines will be created during each iteration over
            '_port_range'. The default is int(30), which means 30 TCP sockets
            in the IPv4 address family will be created and used to obtain open
            ports in the selected target.
        loop_timeout:
            The number of seconds to wait for a single created curtain to
            finish running. By default, is float(1.2).
        open_port:
            Dataclass which will temporarily store detected open port number.
            This detected information will be stored until will not be
            forwarded into 'captured_sensitive_info'.
        service:
            Dataclass which will temporarily store detected service name and
            service version. Those detected information will be stored until
            will not be forwarded into 'captured_sensitive_info'.
        _port_range:
            List of ports that were generated in the given range as the '-p'
            argument in command line. The minimum value to generate ports
            to scan is 1 and maximum is 10000.
        port_amount:
            A helpful variable to determine how many ports have already been
            scanned. The value corresponds to the initial length of the list
            named: '_port_range'.

    .. automethod:: __create_port_scanners_coroutines
    .. automethod:: __check_if_port_is_open
    .. automethod:: __detect_service_name
    .. automethod:: __detect_service_version
    .. automethod:: __save_detected_port_info
    .. automethod:: __prepare_dataclass
    """

    __slots__ = (
        "async_loop",
        "captured_sensitive_info",
        "coroutines_number",
        "loop_timeout",
        "open_port",
        "service",
        "_port_range",
        "port_amount",
    )

    def __init__(self, captured_sensitive_info: CapturedSensitiveInfo,
                 port_amount: int) -> None:
        self.loop_timeout: float = 1.2
        self.coroutines_number: int = 30
        self.port_amount: int = port_amount
        self.port_range: list[int] = port_amount
        self.service: Service = Service()
        self.open_port: OpenPort = OpenPort()
        self.captured_sensitive_info = captured_sensitive_info
        self.async_loop: asyncio.AbstractEventLoop = asyncio.get_running_loop()

    @property
    def port_range(self) -> list[int]:
        """Get port_range.

        Returns:
            '_port_range' list that will be iterated by the TCP port scanner
            while scanning chosen target. The length of this list will also be
            the number of ports that will be scanned.
        """
        return self._port_range

    @port_range.setter
    def port_range(self, port_amount: int) -> None:
        """Set the 'port_range' appropriately to be between minimum and maximum
        value.

        Args:
            port_amount:
                A number of ports to be scanned. Based on this number, a list
                will be created.

        Raises:
            PortRangeError: An error occurred when 'port_amount' value is less
                than int(i) or more than int(10000).
        """
        if not (0 < port_amount < 10000):
            raise PortRangeError(port_amount)
        self._port_range = list(range(1, port_amount + 1))

    async def run_port_scanner(self) -> AsyncIterable:
        """The asynchronous handler of 'PortServiceScannerTCP' with the help of
        which the scanning of the selected target will start.

        Scanning will be done through the creation of 30 coroutines per each
        iteration in 'vulnerability_scanner.executor' also after each single
        iteration from the list will be deleted 30 ports. Scanning of the
        chosen target will continue until each port from 'port_range' has been
        scanned.

        Returns:
            The number of ports that have already been scanned. It will be
            needed to track the progress of the scan.
        """
        while self.port_range:
            await run_concurrently(*[
                coroutine()
                for coroutine in self.__create_port_scanners_coroutines
            ])

            del self.port_range[:self.coroutines_number]
            yield self.port_amount - len(
                self.port_range)  # how many ports have been scanned

    @property
    def __create_port_scanners_coroutines(
            self) -> list[Callable[[int], Awaitable[None]]]:
        """Create 30 coroutines per each call.

        This function will create coroutines, by default 30. Those coroutines
        will be used to scan chosen target. Each one of those coroutines
        creates TCP socket for IPv4 family address. Each one coroutine will
        be used to check if the next port from iteration is open.

        Returns:
            List with coroutines what will be used to scan ports of chosen
            target.
        """
        return [
            partial(self.__check_if_port_is_open, port_number=port_number)
            for port_number in self.port_range[:self.coroutines_number]
        ]

    async def __check_if_port_is_open(self, port_number: int) -> None:
        """By using TCP socket asynchronously verify if provided port
        ('port_number') is open in the selected target to scan.

        This function asynchronously can check only one port per single call
        but per each iteration over port_range 30 of coroutines will be
        created so per each call of '__create_port_scanners_coroutines()' 30
        checks of 30 different ports will be performed. If the port will be
        open, the function will call also '__discover_service_name(
        port_number)' to discover the running service name of this open port
        and 'discover_service_version(tcp_socket)' to discover the version of
        this running service.

        Args:
            port_number:
                The port number what will be scanned in the selected target to
                detect if it is open. If it's open, two functions will be
                called to detect the running service on this port and also
                detect the version of this running service.
        """
        socket.setdefaulttimeout(0.01)
        tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        tcp_socket.setblocking(False)

        try:
            if await asyncio.wait_for(
                    self.async_loop.sock_connect(
                        tcp_socket,
                        (self.captured_sensitive_info.ip, port_number)),
                    timeout=self.loop_timeout,
            ):
                # At this point provided port has been detected as open
                self.open_port.number = port_number
        except (ConnectionRefusedError, OSError, TimeoutError):
            pass
        else:
            # Detect service name running in detected opened port
            self.__detect_service_name(port_number)
            # Detect version of this running service
            await self.__detect_service_version(tcp_socket)
            # Save opened port number, service name and service version
            self.__save_detected_port_info()

    def __detect_service_name(self, port_number: int) -> None:
        """This fnc will try to get what is the name of running service for
        specified port number passed into fnc as parameter.

        Args:
            port_number:
                Currently scanned port on the device selected to scanning.
        """
        self.service.name = PORTS_AND_SERVICES.get(port_number, "Unknown")

    async def __detect_service_version(self, tcp_socket: socket.socket) -> \
            None:
        """By using TCP socket asynchronously detect the version of the running
        service on the opened port in the selected target to scan.

        By receiving 100 bytes from the TCP socket this function is able to
        detect the version of the running service. By default, the time for
        waiting for data from the socket is 1.2 seconds. When it is possible to
        read 100 bytes from TCP socket ('tcp_socket') within the set time, the
        version of running service on opened port will be detected. The
        detected
        version of the service will be saved into field 'version' in dataclass
        'Service'.

        Args:
            tcp_socket:
                TCP socket for IPv4 family address. This socket was used to
                detect whether the port is open as well in
                'check_if_port_is_open'.
        """
        try:
            if service_ver := await asyncio.wait_for(
                    self.async_loop.sock_recv(tcp_socket, 100),
                    timeout=self.loop_timeout):
                # decode detected service version
                service_version: str = service_ver.decode().strip("\n\r")
        except asyncio.exceptions.TimeoutError:
            self.service.version = "Unknown"
        else:
            # Save decoded service version
            self.service.version = service_version
        finally:
            tcp_socket.settimeout(None)
            tcp_socket.close()

    def __save_detected_port_info(self) -> None:
        """Save detected information about scanned port in the target.

        This function will be called per each iteration (iteration per
        coroutine).
        This function will save:
            - port number (if was open)
            - service name (if was detected otherwise will be saved as
                'Unknown')
            - service version (if was detected otherwise will be saved as
                'Unknown')
        """
        # For each iteration create new namedtuple
        port_service = namedtuple("PortService",
                                  "port_number service_name service_version")

        if self.open_port.number:
            self.captured_sensitive_info.ports_services.append(
                port_service(
                    port_number=self.open_port.number,
                    service_name=self.service.name,
                    service_version=self.service.version,
                ))

            self.__prepare_dataclass()

    def __prepare_dataclass(self) -> None:
        """Prepare dataclasses for the next iteration over ports.

        This method must be called to prepare a clean dataclasss for the next
        port which will be scanned. It will only be called if the data classes
        during the iteration were holding some captured information, if
        dataclasss were empty, this method will not be called.
        """
        self.open_port, self.service = OpenPort(), Service()
