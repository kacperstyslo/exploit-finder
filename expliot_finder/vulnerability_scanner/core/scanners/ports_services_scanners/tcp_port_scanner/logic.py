"""Logic of 'tcp_port_scanner' module.

This module will try to detect:
    - open ports (what open ports selected target has)
    - services names (what services running on these open ports)
    - versions of these running services
Information detected by this module will be saved and returned in the following
form:

.. code-block:: python

        # Returns open ports, services names running on those open ports and
        # versions of those services of the chosen target
         ports_services: [
                        PortService(
                            # Detected open port in target
                            port_number=22,
                            # Detected running service on this opened port
                            service_name='ssh',
                            # Detected versions of this running service
                            service_version='SSH-2.0-dropbear_2011.54'
                        ),
                        PortService(
                            port_number=80,
                            service_name='http',
                            service_version='Unknown'
                        )
                        ...
                    ]
"""

__all__ = ("PortServiceScannerTCP",)

import asyncio
import socket
from asyncio.exceptions import TimeoutError as AsyncTimeoutError
from collections import namedtuple
from functools import partial
from typing import AsyncIterable, Awaitable, Callable

from expliot_finder.vulnerability_scanner.captured_sensitive_target_info import \
    CapturedSensitiveInfo
from expliot_finder.vulnerability_scanner.core.utils import run_concurrently

from .const import PORTS_AND_SERVICES
from .exceptions import PortRangeError
from .settings import TCPScannerSettings
from .state import OpenPort, Service


class PortServiceScannerTCP:
    """Asynchronous TCP port/services scanner.

    The methods stored in this class will perform port scan asynchronously
    thus, other modules will not be blocked be scanning. While scanning the
    methods in this class will try to get the following information about
    the target:
        - open ports (numbers)
        - names of services listening on these ports
        - versions of these listening services
    To obtain this about information, 30 coroutines will be created per each
    iteration over 'port_range'. Those 30 coroutines will use TCP socket in
    IPv4 addresses family.

    Attributes:
        async_loop:
            Running event loop in the current OS thread.
        captured_sensitive_info:
            Global dataclass that stores detected sensitive information about
            the selected target to scan. This dataclass can be easily
            transformed to the dictionary.
        open_port:
            Dataclass which will temporarily store detected open port number.
            This detected information will be stored until will not be
            forwarded into 'captured_sensitive_info'.
        scanner_settings:
            An instance of the data class that stores the settings of the TCP
            port scanner and services.
        detected_service:
            Dataclass which will temporarily store detected service name and
            service version. Those detected information will be stored until
            will not be forwarded into 'captured_sensitive_info'.
        _port_range:
            List of ports that were generated in the given range as the '-p'
            argument in command line. The minimum value to generate ports
            to scan is 1 and maximum is 10000.
        start_port_amount:
            A helpful variable to determine how many ports have already been
            scanned. The value corresponds to the initial length of the list
            named: '_port_range'.

    .. automethod:: __create_port_scanners_coroutines
    .. automethod:: __check_if_port_is_open
    .. automethod:: __detect_service_name
    .. automethod:: __detect_service_version
    .. automethod:: __save_detected_port_info
    .. automethod:: __prepare_dataclass
    """

    __slots__ = (
        "async_loop",
        "captured_sensitive_info",
        "coroutines_number",
        "loop_timeout",
        "open_port",
        "detected_service",
        "scanner_settings",
        "_port_range",
        "start_port_amount",
    )

    def __init__(self, captured_sensitive_info: CapturedSensitiveInfo, port_amount: int) -> None:
        """Init PortServiceScannerTCP class.

        Args:
            captured_sensitive_info:
                Global data class what collects scanning results from all
                scanners built-into vulnerability scanner package.
            port_amount:
                Amount of number ports to scan.
        """
        self.start_port_amount: int = port_amount
        self.port_range: list[int] = port_amount  # type: ignore
        self.detected_service: Service = Service()
        self.open_port: OpenPort = OpenPort()
        self.scanner_settings: TCPScannerSettings = TCPScannerSettings()
        self.captured_sensitive_info: CapturedSensitiveInfo = captured_sensitive_info
        self.async_loop: asyncio.AbstractEventLoop = asyncio.get_running_loop()

    @property
    def port_range(self) -> list[int]:
        """Get port_range.

        Returns:
            '_port_range' list that will be iterated by the TCP port scanner
            while scanning chosen target. The length of this list will also be
            the number of ports that will be scanned.
        """
        return self._port_range

    @port_range.setter
    def port_range(self, ports_amount_to_scan: int) -> None:
        """Set the 'port_range' appropriately to be between minimum and maximum value.

        Args:
            ports_amount_to_scan:
                A number of ports to be scanned. Based on this number, a list
                will be created.

        Raises:
            PortRangeError: An error occurred when 'port_amount' value is less
                than int(i) or more than int(10000).
        """
        if not 0 < ports_amount_to_scan < 10000:
            raise PortRangeError(ports_amount_to_scan)
        self._port_range: list[int] = list(range(1, ports_amount_to_scan + 1))

    async def run_port_scanner(self) -> AsyncIterable:
        """Run sequence of functions if order to detect open ports and running service in target.

        This handle will execute functions in following order:
            - Per each iteration over ports create a new set of 30 coroutines.
                Every single coroutine corresponds to one port. Per every single
                iteration, 30 different ports will be scanned at the same time.
            - Asynchronously determine if port is open, if so perform next
                operations in order to detect service name running on this open
                port. If service version will be discovered module also will try
                to detect the version of this running service.
            - Save detected open ports, services, and services versions into
                captured_sensitive_info.

        All blocking functions will be run asynchronously.

        Returns:
            The number of ports that have already been scanned. It will be
            needed to track the progress of the scan.
        """
        while self.port_range:
            await run_concurrently(
                *[
                    coroutine()  # type: ignore
                    for coroutine in self.__create_port_scanners_coroutines
                ]
            )

            del self.port_range[: self.scanner_settings.coroutines_number]
            yield self.start_port_amount - len(self.port_range)  # how many ports have been scanned

    @property
    def __create_port_scanners_coroutines(
        self,
    ) -> list[Callable[[int], Awaitable[None]]]:
        """Create 30 coroutines per each call.

        This function will create coroutines, by default 30. Those coroutines
        will be used to scan chosen target. Each one of those coroutines
        creates TCP socket for IPv4 family address. Each one coroutine will
        be used to check if the next port from iteration is open.

        Returns:
            List with coroutines what will be used to scan ports of chosen
            target.
        """
        return [
            partial(self.__check_if_port_is_open, port_number=port_number)
            for port_number in self.port_range[: self.scanner_settings.coroutines_number]
        ]

    async def __check_if_port_is_open(self, port_number: int) -> None:
        """By using TCP socket asynchronously verify if provided port is open.

        This function asynchronously can check only one port per single call
        but per each iteration over port_range 30 of coroutines will be
        created so per each call of '__create_port_scanners_coroutines()' 30
        checks of 30 different ports will be performed. If the port will be
        open, the function will call also '__discover_service_name(
        port_number)' to discover the running service name of this open port
        and 'discover_service_version(tcp_socket)' to discover the version of
        this running service.

        Args:
            port_number:
                The currently scanned port in selected target to detect if it
                is open. If it's open, two functions will be called to detect
                the running service on this port and also detect the version of
                this running service.
        """
        socket.setdefaulttimeout(0.01)
        tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        tcp_socket.setblocking(False)

        try:
            if await asyncio.wait_for(
                self.async_loop.sock_connect(
                    tcp_socket, (self.captured_sensitive_info.ip_v4, port_number)
                ),
                timeout=self.scanner_settings.loop_timeout,
            ):
                # At this point provided port has been detected as open
                self.open_port.number = port_number
        except (ConnectionRefusedError, OSError, AsyncTimeoutError):
            pass
        else:
            self.__detect_service_name(port_number)
            await self.__detect_service_version(tcp_socket)
            self.__save_detected_port_info()

    def __detect_service_name(self, port_number: int) -> None:
        """Asynchronously detect service running on a chosen port.

        Args:
            port_number:
                Currently scanned port on the device selected to scanning.
        """
        self.detected_service.name = PORTS_AND_SERVICES.get(port_number, "Unknown")

    async def __detect_service_version(self, tcp_socket: socket.socket) -> None:
        """Asynchronously detect service version running on a chosen port.

        Non-blocking asynchronous sockets will be used to determine the version
        of the running service. By receiving 100 bytes from the TCP socket this
        function is able to detect the version of the running service. By default,
        the time for waiting for data from the socket is 1.2 seconds. When it
        is possible to read 100 bytes from TCP socket ('tcp_socket') within the
        set time, the version of running service on opened port will be detected.
        The detected version of the service will be saved into field 'version'
        in dataclass 'Service'.

        Args:
            tcp_socket:
                TCP socket for IPv4 family address. This socket was used to
                detect whether the port is open as well in
                'check_if_port_is_open'.
        """
        try:
            if service_ver := await asyncio.wait_for(
                self.async_loop.sock_recv(tcp_socket, 100),
                timeout=self.scanner_settings.loop_timeout,
            ):
                service_version: str = service_ver.decode().strip("\n\r")
        except asyncio.exceptions.TimeoutError:
            self.detected_service.version = "Unknown"
        else:
            self.detected_service.version = service_version
        finally:
            tcp_socket.settimeout(None)
            tcp_socket.close()

    def __save_detected_port_info(self) -> None:
        """Save detected information about scanned port in the target.

        This function will be called per each iteration (iteration per
        coroutine). This function will save:
            - port number (if was open)
            - service name (if was detected otherwise will be saved as 'Unknown')
            - service version (if was detected otherwise will be saved as 'Unknown')
        """
        # For each iteration create new namedtuple
        port_service = namedtuple("port_service", "port_number service_name service_version")

        if self.open_port.number:
            self.captured_sensitive_info.ports_services.append(
                port_service(
                    port_number=self.open_port.number,
                    service_name=self.detected_service.name,
                    service_version=self.detected_service.version,
                )
            )

            self.__prepare_dataclass()

    def __prepare_dataclass(self) -> None:
        """Prepare dataclasses for the next iteration over ports.

        This method must be called to prepare a clean data class for the next
        port which will be scanned. It will only be called if the data classes
        during the iteration were holding some captured information, if
        data class were empty, this method will not be called.
        """
        self.open_port, self.detected_service = OpenPort(), Service()
